use crate::models::module::ModuleDefinition;
use std::collections::HashMap;
use std::fmt::Write;

/// Parameters for generating a new game's config.toml
pub struct NewGameConfig {
    pub name: String,
    pub display_name: Option<String>,
    pub username: Option<String>,
    pub game_type: String,
    pub version: u32,
    pub profiles: u32,
    pub weapon_names: Vec<String>,
    pub modules: Vec<ModuleDefinition>,
    pub module_params: HashMap<String, HashMap<String, String>>,
    pub quick_toggles: HashMap<String, String>,
}

/// Generate the config.toml content for a new game
pub fn generate_config_toml(cfg: &NewGameConfig) -> String {
    let mut out = String::with_capacity(4096);

    // Header
    writeln!(out, "# {} Game Configuration", cfg.name).unwrap();
    writeln!(out, "# Generated by GPC IDE - edit as needed").unwrap();
    writeln!(
        out,
        "# This file is read by generate.py to create menu GPC files"
    )
    .unwrap();
    writeln!(out).unwrap();
    if let Some(ref display_name) = cfg.display_name {
        writeln!(out, "name = \"{}\"", display_name).unwrap();
    }
    let filename = build_filename(cfg.username.as_deref(), &cfg.name);
    writeln!(out, "filename = \"{}\"", filename).unwrap();
    writeln!(out, "version = {}", cfg.version).unwrap();
    writeln!(out, "type = \"{}\"", cfg.game_type).unwrap();
    writeln!(out, "profile_count = {}", cfg.profiles).unwrap();

    // Weapon names (if weapondata module is present)
    let has_weapondata = cfg.modules.iter().any(|m| m.id == "weapondata");
    if has_weapondata && !cfg.weapon_names.is_empty() {
        writeln!(out).unwrap();
        writeln!(
            out,
            "# Weapon names - edit these to match your game's weapons"
        )
        .unwrap();
        writeln!(out, "weapons = [").unwrap();
        for name in &cfg.weapon_names {
            writeln!(out, "    \"{}\",", name).unwrap();
        }
        writeln!(out, "]").unwrap();
    }

    // State screen
    writeln!(out).unwrap();
    writeln!(out, "[state_screen]").unwrap();
    let title_name = cfg.display_name.as_deref().unwrap_or(&cfg.name);
    writeln!(
        out,
        "title = \"{}-v{}\"",
        title_name, cfg.version
    )
    .unwrap();

    // Buttons
    writeln!(out).unwrap();
    writeln!(out, "[buttons]").unwrap();
    writeln!(out, "menu_mod = \"PS5_L2\"").unwrap();
    writeln!(out, "menu_btn = \"PS5_OPTIONS\"").unwrap();
    writeln!(out, "confirm = \"PS5_CROSS\"").unwrap();
    writeln!(out, "cancel = \"PS5_CIRCLE\"").unwrap();
    writeln!(out, "up = \"PS5_UP\"").unwrap();
    writeln!(out, "down = \"PS5_DOWN\"").unwrap();
    writeln!(out, "left = \"PS5_LEFT\"").unwrap();
    writeln!(out, "right = \"PS5_RIGHT\"").unwrap();

    // Keyboard (quick toggles)
    writeln!(out).unwrap();
    writeln!(out, "[keyboard]").unwrap();
    for (module_id, key) in &cfg.quick_toggles {
        if !key.is_empty() {
            writeln!(out, "quick_toggle_{} = \"{}\"", module_id, key).unwrap();
        }
    }

    // Menu items
    writeln!(out).unwrap();
    writeln!(out, "# Menu items").unwrap();

    let has_adp = cfg.modules.iter().any(|m| m.id == "adp");

    // Sort modules: those with menu_priority first (lower = earlier), then the rest
    let mut priority_modules: Vec<&ModuleDefinition> = cfg
        .modules
        .iter()
        .filter(|m| m.menu_priority.is_some())
        .collect();
    priority_modules.sort_by_key(|m| m.menu_priority.unwrap_or(100));

    let non_priority_modules: Vec<&ModuleDefinition> = cfg
        .modules
        .iter()
        .filter(|m| m.menu_priority.is_none())
        .collect();

    // Render priority modules first, then non-priority
    for module in priority_modules
        .iter()
        .chain(non_priority_modules.iter())
    {
        write_module_menu(&mut out, module, cfg.profiles, has_adp);
    }

    // Module params
    if !cfg.module_params.is_empty() {
        writeln!(out).unwrap();
        writeln!(out, "# Per-module configurable parameters (buttons/keys)").unwrap();
        for (module_id, params) in &cfg.module_params {
            writeln!(out, "[module_params.{}]", module_id).unwrap();
            for (key, value) in params {
                writeln!(out, "{} = \"{}\"", key, value).unwrap();
            }
        }
    }

    // Extra vars
    let extra_vars = collect_extra_vars(&cfg.modules);
    if !extra_vars.is_empty() {
        writeln!(out).unwrap();
        writeln!(out, "# Extra variables for combos").unwrap();
        writeln!(out, "[extra_vars]").unwrap();
        let weapons_count = if cfg.weapon_names.is_empty() {
            30
        } else {
            cfg.weapon_names.len()
        };
        for (var, var_type) in &extra_vars {
            if var == "Weapons_RecoilValues" {
                let count = if has_adp {
                    (weapons_count + 1) * 2
                } else {
                    weapons_count * 2
                };
                writeln!(
                    out,
                    "{} = \"int[{}]\"  # {} weapons * 2 values (V/H)",
                    var, count, weapons_count
                )
                .unwrap();
            } else {
                writeln!(out, "{} = \"{}\"", var, var_type).unwrap();
            }
        }
    }

    out
}

fn write_module_menu(
    out: &mut String,
    module: &ModuleDefinition,
    profiles: u32,
    has_adp: bool,
) {
    if let Some(ref config_menu) = module.config_menu {
        // Module has a custom config_menu definition
        if module.id == "weapondata" && has_adp {
            // When ADP is present, weapondata becomes data-only (ADP handles menu)
            writeln!(out).unwrap();
            writeln!(
                out,
                "# Data module: Weapon Data (provides arrays, ADP handles menu)"
            )
            .unwrap();
            writeln!(out, "[[menu]]").unwrap();
            writeln!(out, "name = \"Weapon Data\"").unwrap();
            writeln!(out, "module = \"weapondata\"").unwrap();
            writeln!(out, "type = \"data\"").unwrap();
        } else {
            writeln!(out).unwrap();
            writeln!(out, "[[menu]]").unwrap();
            writeln!(out, "name = \"{}\"", config_menu.name).unwrap();
            writeln!(out, "module = \"{}\"", module.id).unwrap();
            writeln!(out, "type = \"{}\"", config_menu.r#type).unwrap();
            if let Some(ref sd) = module.state_display {
                writeln!(out, "state_display = \"{}\"", sd).unwrap();
            }
            if let Some(ref sv) = module.status_var {
                writeln!(out, "status_var = \"{}\"", sv).unwrap();
            }
            if let Some(ref df) = config_menu.display_function {
                writeln!(out, "display_function = \"{}\"", df).unwrap();
            }
            if let Some(ref ef) = config_menu.edit_function {
                writeln!(out, "edit_function = \"{}\"", ef).unwrap();
            }
            if profiles > 0 {
                writeln!(out, "profile_aware = true").unwrap();
            }
        }
    } else if !module.options.is_empty() {
        // Module has options -> clickable submenu
        writeln!(out).unwrap();
        writeln!(out, "[[menu]]").unwrap();
        writeln!(out, "name = \"{}\"", module.display_name).unwrap();
        writeln!(out, "module = \"{}\"", module.id).unwrap();
        writeln!(out, "type = \"clickable\"").unwrap();
        if let Some(ref sd) = module.state_display {
            writeln!(out, "state_display = \"{}\"", sd).unwrap();
        }
        if let Some(ref sv) = module.status_var {
            writeln!(out, "status_var = \"{}\"", sv).unwrap();
        }

        for opt in &module.options {
            writeln!(out).unwrap();
            writeln!(out, "[[menu.options]]").unwrap();
            writeln!(out, "name = \"{}\"", opt.name).unwrap();
            writeln!(out, "var = \"{}\"", opt.var).unwrap();
            writeln!(out, "type = \"{}\"", opt.r#type).unwrap();
            if let Some(ref default) = opt.default {
                writeln!(out, "default = {}", format_toml_value(default)).unwrap();
            }
            if opt.r#type == "value" {
                if let Some(min) = opt.min {
                    writeln!(out, "min = {}", min).unwrap();
                }
                if let Some(max) = opt.max {
                    writeln!(out, "max = {}", max).unwrap();
                }
            }
            if profiles > 0 {
                writeln!(out, "profile_aware = true").unwrap();
            }
        }
    } else if module.requires_keyboard_file.unwrap_or(false) {
        // Keyboard module - no menu entry needed
    }
    // else: no menu entry for this module (data-only or code-only)
}

fn format_toml_value(val: &serde_json::Value) -> String {
    match val {
        serde_json::Value::Number(n) => n.to_string(),
        serde_json::Value::Bool(b) => b.to_string(),
        serde_json::Value::String(s) => format!("\"{}\"", s),
        _ => val.to_string(),
    }
}

/// Normalize a string for safe use in filenames: keep alphanumeric, replace spaces/unsafe chars
fn normalize_for_filename(s: &str) -> String {
    s.chars()
        .filter(|c| c.is_alphanumeric() || *c == '-' || *c == '_')
        .collect()
}

/// Build the filename prefix: "{username}-{game}-v" or "{game}-v" if no username
fn build_filename(username: Option<&str>, game_name: &str) -> String {
    let normalized_game = normalize_for_filename(game_name);
    match username {
        Some(u) if !u.trim().is_empty() => {
            let normalized_user = normalize_for_filename(u);
            format!("{}-{}-v", normalized_user, normalized_game)
        }
        _ => format!("{}-v", normalized_game),
    }
}

fn collect_extra_vars(modules: &[ModuleDefinition]) -> Vec<(String, String)> {
    let mut vars: Vec<(String, String)> = Vec::new();
    let mut seen = std::collections::HashSet::new();
    for module in modules {
        for (var, var_type) in &module.extra_vars {
            if !seen.contains(var) {
                seen.insert(var.clone());
                vars.push((var.clone(), var_type.clone()));
            }
        }
    }
    vars.sort_by(|a, b| a.0.cmp(&b.0));
    vars
}
