use crate::models::config::GameConfig;
use crate::models::module::ModuleDefinition;
use std::collections::HashMap;
use std::fmt::Write;

/// Parameters for generating a new game's config.toml
pub struct NewGameConfig {
    pub name: String,
    pub display_name: Option<String>,
    pub username: Option<String>,
    pub game_type: String,
    pub console_type: Option<String>,
    pub version: u32,
    pub profiles: u32,
    pub weapon_names: Vec<String>,
    pub modules: Vec<ModuleDefinition>,
    pub module_params: HashMap<String, HashMap<String, String>>,
    pub quick_toggles: HashMap<String, String>,
}

/// Generate the config.toml content for a new game
pub fn generate_config_toml(cfg: &NewGameConfig) -> String {
    let mut out = String::with_capacity(4096);

    // Header
    writeln!(out, "# {} Game Configuration", cfg.name).unwrap();
    writeln!(out, "# Generated by GPC IDE - edit as needed").unwrap();
    writeln!(
        out,
        "# This file is read by generate.py to create menu GPC files"
    )
    .unwrap();
    writeln!(out).unwrap();
    if let Some(ref display_name) = cfg.display_name {
        writeln!(out, "name = \"{}\"", display_name).unwrap();
    }
    if let Some(ref username) = cfg.username {
        if !username.trim().is_empty() {
            writeln!(out, "username = \"{}\"", username).unwrap();
        }
    }
    let filename = build_filename(cfg.username.as_deref(), &cfg.name);
    writeln!(out, "filename = \"{}\"", filename).unwrap();
    writeln!(out, "version = {}", cfg.version).unwrap();
    writeln!(out, "type = \"{}\"", cfg.game_type).unwrap();
    let ct = cfg.console_type.as_deref().unwrap_or("ps5");
    writeln!(out, "console_type = \"{}\"", ct).unwrap();
    writeln!(out, "profile_count = {}", cfg.profiles).unwrap();

    // Weapon names (if weapondata module is present)
    let has_weapondata = cfg.modules.iter().any(|m| m.id == "weapondata");
    if has_weapondata && !cfg.weapon_names.is_empty() {
        writeln!(out).unwrap();
        writeln!(
            out,
            "# Weapon names - edit these to match your game's weapons"
        )
        .unwrap();
        writeln!(out, "weapons = [").unwrap();
        for name in &cfg.weapon_names {
            writeln!(out, "    \"{}\",", name).unwrap();
        }
        writeln!(out, "]").unwrap();
    }

    // State screen
    writeln!(out).unwrap();
    writeln!(out, "[state_screen]").unwrap();
    writeln!(out, "title = \"{{game}}-v{{version}}\"").unwrap();

    // Buttons
    let btn = default_buttons(ct);
    writeln!(out).unwrap();
    writeln!(out, "[buttons]").unwrap();
    writeln!(out, "menu_mod = \"{}\"", btn.menu_mod).unwrap();
    writeln!(out, "menu_btn = \"{}\"", btn.menu_btn).unwrap();
    writeln!(out, "confirm = \"{}\"", btn.confirm).unwrap();
    writeln!(out, "cancel = \"{}\"", btn.cancel).unwrap();
    writeln!(out, "up = \"{}\"", btn.up).unwrap();
    writeln!(out, "down = \"{}\"", btn.down).unwrap();
    writeln!(out, "left = \"{}\"", btn.left).unwrap();
    writeln!(out, "right = \"{}\"", btn.right).unwrap();

    // Keyboard (quick toggles)
    writeln!(out).unwrap();
    writeln!(out, "[keyboard]").unwrap();
    for (module_id, key) in &cfg.quick_toggles {
        if !key.is_empty() {
            writeln!(out, "quick_toggle_{} = \"{}\"", module_id, key).unwrap();
        }
    }

    // Menu items
    writeln!(out).unwrap();
    writeln!(out, "# Menu items").unwrap();

    let has_adp = cfg.modules.iter().any(|m| m.id == "adp");

    // Sort modules: those with menu_priority first (lower = earlier), then the rest
    let mut priority_modules: Vec<&ModuleDefinition> = cfg
        .modules
        .iter()
        .filter(|m| m.menu_priority.is_some())
        .collect();
    priority_modules.sort_by_key(|m| m.menu_priority.unwrap_or(100));

    let non_priority_modules: Vec<&ModuleDefinition> = cfg
        .modules
        .iter()
        .filter(|m| m.menu_priority.is_none())
        .collect();

    // Render priority modules first, then non-priority
    for module in priority_modules
        .iter()
        .chain(non_priority_modules.iter())
    {
        write_module_menu(&mut out, module, cfg.profiles, has_adp);
    }

    // Module params
    if !cfg.module_params.is_empty() {
        writeln!(out).unwrap();
        writeln!(out, "# Per-module configurable parameters (buttons/keys)").unwrap();
        for (module_id, params) in &cfg.module_params {
            writeln!(out, "[module_params.{}]", module_id).unwrap();
            for (key, value) in params {
                writeln!(out, "{} = \"{}\"", key, value).unwrap();
            }
        }
    }

    // Extra vars
    let extra_vars = collect_extra_vars(&cfg.modules);
    if !extra_vars.is_empty() {
        writeln!(out).unwrap();
        writeln!(out, "# Extra variables for combos").unwrap();
        writeln!(out, "[extra_vars]").unwrap();
        let weapons_count = if cfg.weapon_names.is_empty() {
            30
        } else {
            cfg.weapon_names.len()
        };
        for (var, var_type) in &extra_vars {
            if var == "Weapons_RecoilValues" {
                let count = if has_adp {
                    (weapons_count + 1) * 2
                } else {
                    weapons_count * 2
                };
                writeln!(
                    out,
                    "{} = \"int[{}]\"  # {} weapons * 2 values (V/H)",
                    var, count, weapons_count
                )
                .unwrap();
            } else {
                writeln!(out, "{} = \"{}\"", var, var_type).unwrap();
            }
        }
    }

    out
}

fn write_module_menu(
    out: &mut String,
    module: &ModuleDefinition,
    profiles: u32,
    has_adp: bool,
) {
    if let Some(ref config_menu) = module.config_menu {
        // Module has a custom config_menu definition
        if module.id == "weapondata" && has_adp {
            // When ADP is present, weapondata becomes data-only (ADP handles menu)
            writeln!(out).unwrap();
            writeln!(
                out,
                "# Data module: Weapon Data (provides arrays, ADP handles menu)"
            )
            .unwrap();
            writeln!(out, "[[menu]]").unwrap();
            writeln!(out, "name = \"Weapon Data\"").unwrap();
            writeln!(out, "module = \"weapondata\"").unwrap();
            writeln!(out, "type = \"data\"").unwrap();
        } else {
            writeln!(out).unwrap();
            writeln!(out, "[[menu]]").unwrap();
            writeln!(out, "name = \"{}\"", config_menu.name).unwrap();
            writeln!(out, "module = \"{}\"", module.id).unwrap();
            writeln!(out, "type = \"{}\"", config_menu.r#type).unwrap();
            if let Some(ref sd) = module.state_display {
                writeln!(out, "state_display = \"{}\"", sd).unwrap();
            }
            if let Some(ref sv) = module.status_var {
                writeln!(out, "status_var = \"{}\"", sv).unwrap();
            }
            if let Some(ref df) = config_menu.display_function {
                writeln!(out, "display_function = \"{}\"", df).unwrap();
            }
            if let Some(ref ef) = config_menu.edit_function {
                writeln!(out, "edit_function = \"{}\"", ef).unwrap();
            }
            if let Some(ref rf) = config_menu.render_function {
                writeln!(out, "render_function = \"{}\"", rf).unwrap();
            }
            // Emit option_labels from module options so the generator
            // can create the OptionText string array for custom render functions
            if !module.options.is_empty() {
                let labels: Vec<String> = module
                    .options
                    .iter()
                    .map(|o| format!("\"{}\"", o.name))
                    .collect();
                writeln!(out, "option_labels = [{}]", labels.join(", ")).unwrap();
            }
            if profiles > 0 {
                writeln!(out, "profile_aware = true").unwrap();
            }
        }
    } else if !module.options.is_empty() {
        // Module has options -> clickable submenu
        writeln!(out).unwrap();
        writeln!(out, "[[menu]]").unwrap();
        writeln!(out, "name = \"{}\"", module.display_name).unwrap();
        writeln!(out, "module = \"{}\"", module.id).unwrap();
        writeln!(out, "type = \"clickable\"").unwrap();
        if let Some(ref sd) = module.state_display {
            writeln!(out, "state_display = \"{}\"", sd).unwrap();
        }
        if let Some(ref sv) = module.status_var {
            writeln!(out, "status_var = \"{}\"", sv).unwrap();
        }

        for opt in &module.options {
            writeln!(out).unwrap();
            writeln!(out, "[[menu.options]]").unwrap();
            writeln!(out, "name = \"{}\"", opt.name).unwrap();
            writeln!(out, "var = \"{}\"", opt.var).unwrap();
            writeln!(out, "type = \"{}\"", opt.r#type).unwrap();
            if let Some(ref default) = opt.default {
                writeln!(out, "default = {}", format_toml_value(default)).unwrap();
            }
            if opt.r#type == "value" {
                if let Some(min) = opt.min {
                    writeln!(out, "min = {}", min).unwrap();
                }
                if let Some(max) = opt.max {
                    writeln!(out, "max = {}", max).unwrap();
                }
            }
            if profiles > 0 {
                writeln!(out, "profile_aware = true").unwrap();
            }
        }
    } else if module.requires_keyboard_file.unwrap_or(false) {
        // Keyboard module - no menu entry needed
    }
    // else: no menu entry for this module (data-only or code-only)
}

fn format_toml_value(val: &serde_json::Value) -> String {
    match val {
        serde_json::Value::Number(n) => n.to_string(),
        serde_json::Value::Bool(b) => b.to_string(),
        serde_json::Value::String(s) => format!("\"{}\"", s),
        _ => val.to_string(),
    }
}

/// Normalize a string for safe use in filenames: keep alphanumeric, replace spaces/unsafe chars
pub(crate) fn normalize_for_filename(s: &str) -> String {
    s.chars()
        .filter(|c| c.is_alphanumeric() || *c == '-' || *c == '_')
        .collect()
}

/// Resolve template variables in a config string.
/// Supports: {version}, {game}, {gameabbr}, {username}, {type}
pub fn resolve_config_template(template: &str, config: &GameConfig) -> String {
    let game_name = config.name.as_deref().unwrap_or("");
    let gameabbr = normalize_for_filename(game_name);
    let username = config.username.as_deref().unwrap_or("");

    template
        .replace("{version}", &config.version.to_string())
        .replace("{game}", game_name)
        .replace("{gameabbr}", &gameabbr)
        .replace("{username}", username)
        .replace("{type}", config.r#type.as_deref().unwrap_or("fps"))
}

/// Build the filename template: "{username}-{gameabbr}-v{version}" or "{gameabbr}-v{version}"
fn build_filename(username: Option<&str>, _game_name: &str) -> String {
    match username {
        Some(u) if !u.trim().is_empty() => "{username}-{gameabbr}-v{version}".to_string(),
        _ => "{gameabbr}-v{version}".to_string(),
    }
}

pub(crate) struct ConsoleDefaults {
    pub menu_mod: &'static str,
    pub menu_btn: &'static str,
    pub confirm: &'static str,
    pub cancel: &'static str,
    pub up: &'static str,
    pub down: &'static str,
    pub left: &'static str,
    pub right: &'static str,
    pub fire: &'static str,
    pub ads: &'static str,
    pub rx: &'static str,
    pub ry: &'static str,
    pub lx: &'static str,
    pub ly: &'static str,
}

pub(crate) fn default_buttons(console_type: &str) -> ConsoleDefaults {
    match console_type {
        "xb1" => ConsoleDefaults {
            menu_mod: "XB1_LT", menu_btn: "XB1_MENU",
            confirm: "XB1_A", cancel: "XB1_B",
            up: "XB1_UP", down: "XB1_DOWN", left: "XB1_LEFT", right: "XB1_RIGHT",
            fire: "XB1_RT", ads: "XB1_LT",
            rx: "XB1_RX", ry: "XB1_RY", lx: "XB1_LX", ly: "XB1_LY",
        },
        "swi" => ConsoleDefaults {
            menu_mod: "SWI_ZL", menu_btn: "SWI_PLUS",
            confirm: "SWI_B", cancel: "SWI_A",
            up: "SWI_UP", down: "SWI_DOWN", left: "SWI_LEFT", right: "SWI_RIGHT",
            fire: "SWI_ZR", ads: "SWI_ZL",
            rx: "SWI_RX", ry: "SWI_RY", lx: "SWI_LX", ly: "SWI_LY",
        },
        "wii" => ConsoleDefaults {
            menu_mod: "WII_ZL", menu_btn: "WII_PLUS",
            confirm: "WII_A", cancel: "WII_B",
            up: "WII_UP", down: "WII_DOWN", left: "WII_LEFT", right: "WII_RIGHT",
            fire: "WII_ZR", ads: "WII_ZL",
            rx: "WII_RX", ry: "WII_RY", lx: "WII_LX", ly: "WII_LY",
        },
        _ => ConsoleDefaults { // ps5 default
            menu_mod: "PS5_L2", menu_btn: "PS5_OPTIONS",
            confirm: "PS5_CROSS", cancel: "PS5_CIRCLE",
            up: "PS5_UP", down: "PS5_DOWN", left: "PS5_LEFT", right: "PS5_RIGHT",
            fire: "PS5_R2", ads: "PS5_L2",
            rx: "PS5_RX", ry: "PS5_RY", lx: "PS5_LX", ly: "PS5_LY",
        },
    }
}

fn collect_extra_vars(modules: &[ModuleDefinition]) -> Vec<(String, String)> {
    let mut vars: Vec<(String, String)> = Vec::new();
    let mut seen = std::collections::HashSet::new();
    for module in modules {
        for (var, var_type) in &module.extra_vars {
            if !seen.contains(var) {
                seen.insert(var.clone());
                vars.push((var.clone(), var_type.clone()));
            }
        }
    }
    vars.sort_by(|a, b| a.0.cmp(&b.0));
    vars
}
