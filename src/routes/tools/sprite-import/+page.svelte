<script lang="ts">
	import { goto } from '$app/navigation';
	import { addToast } from '$lib/stores/toast.svelte';

	let imageFile = $state<File | null>(null);
	let imageUrl = $state('');
	let imgEl: HTMLImageElement | undefined = $state();
	let imgLoaded = $state(false);

	// Source image dimensions
	let srcWidth = $state(0);
	let srcHeight = $state(0);

	// Grid settings
	let cellWidth = $state(16);
	let cellHeight = $state(16);
	let threshold = $state(128);

	// Computed grid
	let cols = $derived(srcWidth > 0 ? Math.floor(srcWidth / cellWidth) : 0);
	let rows = $derived(srcHeight > 0 ? Math.floor(srcHeight / cellHeight) : 0);
	let frameCount = $derived(cols * rows);

	// Frame data
	let frames = $state<{ index: number; bytes: number[] }[]>([]);
	let gpcCode = $state('');
	let spriteName = $state('sprite');

	// Preview
	let previewCanvases = $state<HTMLCanvasElement[]>([]);
	let gridCanvas: HTMLCanvasElement | undefined = $state();

	function handleFileInput(e: Event) {
		const input = e.target as HTMLInputElement;
		const file = input.files?.[0];
		if (!file) return;

		if (!file.type.startsWith('image/')) {
			addToast('Please select an image file', 'error');
			return;
		}

		imageFile = file;
		if (imageUrl) URL.revokeObjectURL(imageUrl);
		imageUrl = URL.createObjectURL(file);
		imgLoaded = false;
		frames = [];
		gpcCode = '';
	}

	function handleImageLoad() {
		if (!imgEl) return;
		srcWidth = imgEl.naturalWidth;
		srcHeight = imgEl.naturalHeight;
		imgLoaded = true;
		drawGrid();
	}

	// Redraw grid overlay when settings change
	$effect(() => {
		if (imgLoaded) {
			void cellWidth;
			void cellHeight;
			drawGrid();
		}
	});

	// Regenerate GPC code when frames or name change
	$effect(() => {
		if (frames.length > 0) {
			gpcCode = generateGpc(spriteName, frames, cellWidth, cellHeight);
		}
	});

	function drawGrid() {
		if (!gridCanvas || !imgEl) return;

		const scale = Math.min(1, 600 / srcWidth, 400 / srcHeight);
		gridCanvas.width = srcWidth * scale;
		gridCanvas.height = srcHeight * scale;

		const ctx = gridCanvas.getContext('2d');
		if (!ctx) return;

		ctx.drawImage(imgEl, 0, 0, gridCanvas.width, gridCanvas.height);

		// Draw grid lines
		ctx.strokeStyle = 'rgba(0, 255, 128, 0.5)';
		ctx.lineWidth = 1;

		for (let c = 0; c <= cols; c++) {
			const x = c * cellWidth * scale;
			ctx.beginPath();
			ctx.moveTo(x, 0);
			ctx.lineTo(x, rows * cellHeight * scale);
			ctx.stroke();
		}
		for (let r = 0; r <= rows; r++) {
			const y = r * cellHeight * scale;
			ctx.beginPath();
			ctx.moveTo(0, y);
			ctx.lineTo(cols * cellWidth * scale, y);
			ctx.stroke();
		}
	}

	function sliceFrames() {
		if (!imgEl || !imgLoaded) return;

		// Draw full image to offscreen canvas
		const offscreen = document.createElement('canvas');
		offscreen.width = srcWidth;
		offscreen.height = srcHeight;
		const ctx = offscreen.getContext('2d');
		if (!ctx) return;
		ctx.drawImage(imgEl, 0, 0);

		const result: { index: number; bytes: number[] }[] = [];

		for (let r = 0; r < rows; r++) {
			for (let c = 0; c < cols; c++) {
				const sx = c * cellWidth;
				const sy = r * cellHeight;
				const imageData = ctx.getImageData(sx, sy, cellWidth, cellHeight);
				const bytes = pixelsToPacked(imageData.data, cellWidth, cellHeight, threshold);
				result.push({ index: r * cols + c, bytes });
			}
		}

		frames = result;
		addToast(`Sliced ${result.length} frames (${cellWidth}x${cellHeight})`, 'success');
	}

	function pixelsToPacked(
		rgba: Uint8ClampedArray,
		w: number,
		h: number,
		thresh: number
	): number[] {
		// Pack pixels into bytes, 8 pixels per byte, MSB = leftmost
		const bytesPerRow = Math.ceil(w / 8);
		const result: number[] = new Array(bytesPerRow * h).fill(0);

		for (let y = 0; y < h; y++) {
			for (let x = 0; x < w; x++) {
				const i = (y * w + x) * 4;
				const gray = rgba[i] * 0.299 + rgba[i + 1] * 0.587 + rgba[i + 2] * 0.114;
				const alpha = rgba[i + 3];
				const isLit = alpha > 128 && gray >= thresh;

				if (isLit) {
					const byteIdx = y * bytesPerRow + Math.floor(x / 8);
					const bitIdx = 7 - (x % 8);
					result[byteIdx] |= 1 << bitIdx;
				}
			}
		}

		return result;
	}

	function generateGpc(
		name: string,
		frms: { index: number; bytes: number[] }[],
		w: number,
		h: number
	): string {
		const safeName = name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^[0-9]/, '_$&');
		const bytesPerRow = Math.ceil(w / 8);
		const bytesPerFrame = bytesPerRow * h;
		const lines: string[] = [];

		lines.push(`// Sprite: ${name} (${w}x${h}, ${frms.length} frames)`);
		lines.push(`// Generated by GPC IDE - Sprite Sheet Import`);
		lines.push(``);
		lines.push(`define SPRITE_${safeName.toUpperCase()}_W      = ${w};`);
		lines.push(`define SPRITE_${safeName.toUpperCase()}_H      = ${h};`);
		lines.push(`define SPRITE_${safeName.toUpperCase()}_FRAMES = ${frms.length};`);
		lines.push(`define SPRITE_${safeName.toUpperCase()}_FBYTES = ${bytesPerFrame};`);
		lines.push(``);

		lines.push(
			`// Frame data: ${frms.length} frames x ${bytesPerFrame} bytes = ${frms.length * bytesPerFrame} total`
		);
		lines.push(`const int8 ${safeName}_data[] = {`);

		for (let fi = 0; fi < frms.length; fi++) {
			const frame = frms[fi];
			lines.push(`    // Frame ${fi}`);
			for (let row = 0; row < h; row++) {
				const offset = row * bytesPerRow;
				const rowBytes = frame.bytes.slice(offset, offset + bytesPerRow);
				const hex = rowBytes.map(
					(b) => '0x' + b.toString(16).toUpperCase().padStart(2, '0')
				);
				const comma = fi < frms.length - 1 || row < h - 1 ? ',' : '';
				lines.push(`    ${hex.join(', ')}${comma}`);
			}
		}

		lines.push(`};`);
		lines.push(``);

		// Draw function
		lines.push(`int _sp_i, _sp_r, _sp_b, _sp_bv, _sp_px;`);
		lines.push(``);
		lines.push(
			`function DrawSprite_${safeName}(int x, int y, int frame) {`
		);
		lines.push(`    for(_sp_r = 0; _sp_r < ${h}; _sp_r++) {`);
		lines.push(
			`        for(_sp_i = 0; _sp_i < ${bytesPerRow}; _sp_i++) {`
		);
		lines.push(
			`            _sp_bv = ${safeName}_data[frame * ${bytesPerFrame} + _sp_r * ${bytesPerRow} + _sp_i];`
		);
		lines.push(`            if(_sp_bv == 0) continue;`);
		lines.push(`            _sp_px = _sp_i * 8;`);
		lines.push(`            for(_sp_b = 7; _sp_b >= 0; _sp_b--) {`);
		lines.push(`                if(_sp_bv & (1 << _sp_b)) {`);
		lines.push(
			`                    pixel_oled(x + _sp_px + (7 - _sp_b), y + _sp_r, 1);`
		);
		lines.push(`                }`);
		lines.push(`            }`);
		lines.push(`        }`);
		lines.push(`    }`);
		lines.push(`}`);

		return lines.join('\n');
	}

	async function copyCode() {
		try {
			await navigator.clipboard.writeText(gpcCode);
			addToast('GPC code copied to clipboard', 'success');
		} catch {
			addToast('Failed to copy', 'error');
		}
	}

	function renderFramePreview(canvas: HTMLCanvasElement, bytes: number[], w: number, h: number) {
		const scale = Math.max(2, Math.min(4, Math.floor(64 / Math.max(w, h))));
		canvas.width = w * scale;
		canvas.height = h * scale;
		const ctx = canvas.getContext('2d');
		if (!ctx) return;

		ctx.fillStyle = '#101010';
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		ctx.fillStyle = '#00ff80';
		const bytesPerRow = Math.ceil(w / 8);

		for (let y = 0; y < h; y++) {
			for (let x = 0; x < w; x++) {
				const byteIdx = y * bytesPerRow + Math.floor(x / 8);
				const bitIdx = 7 - (x % 8);
				if (bytes[byteIdx] & (1 << bitIdx)) {
					ctx.fillRect(x * scale, y * scale, scale, scale);
				}
			}
		}
	}

	// Render frame previews when frames change
	$effect(() => {
		if (frames.length > 0) {
			requestAnimationFrame(() => {
				const canvases = document.querySelectorAll<HTMLCanvasElement>('.frame-preview');
				canvases.forEach((canvas, i) => {
					if (i < frames.length) {
						renderFramePreview(canvas, frames[i].bytes, cellWidth, cellHeight);
					}
				});
			});
		}
	});
</script>

<div class="flex h-full flex-col bg-zinc-950 text-zinc-200">
	<!-- Header -->
	<div class="flex items-center gap-3 border-b border-zinc-800 px-4 py-3">
		<button
			class="rounded p-1 text-zinc-500 hover:bg-zinc-800 hover:text-zinc-300"
			onclick={() => goto('/')}
			title="Back"
		>
			<svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
				<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
			</svg>
		</button>
		<h1 class="text-lg font-bold">Sprite Sheet Import</h1>
		<span class="text-xs text-zinc-500">Import sprite sheets and convert to OLED byte arrays</span>
	</div>

	<!-- Controls -->
	<div class="flex flex-wrap items-center gap-3 border-b border-zinc-800 p-4">
		<label
			class="cursor-pointer rounded bg-emerald-600 px-4 py-1.5 text-xs font-medium text-white hover:bg-emerald-500"
		>
			Load Image
			<input
				type="file"
				accept="image/*"
				class="hidden"
				onchange={handleFileInput}
			/>
		</label>

		{#if imgLoaded}
			<div class="mx-2 h-5 w-px bg-zinc-700"></div>
			<div class="flex items-center gap-2">
				<label class="text-[10px] text-zinc-500 uppercase">Cell W</label>
				<input
					type="number"
					class="w-14 rounded border border-zinc-700 bg-zinc-800 px-2 py-1 text-xs text-zinc-200 outline-none focus:border-emerald-500"
					bind:value={cellWidth}
					min="4"
					max="128"
				/>
			</div>
			<div class="flex items-center gap-2">
				<label class="text-[10px] text-zinc-500 uppercase">Cell H</label>
				<input
					type="number"
					class="w-14 rounded border border-zinc-700 bg-zinc-800 px-2 py-1 text-xs text-zinc-200 outline-none focus:border-emerald-500"
					bind:value={cellHeight}
					min="4"
					max="64"
				/>
			</div>
			<div class="flex items-center gap-2">
				<label class="text-[10px] text-zinc-500 uppercase">Threshold</label>
				<input
					type="range"
					class="w-20"
					bind:value={threshold}
					min="1"
					max="255"
				/>
				<span class="text-[10px] text-zinc-500">{threshold}</span>
			</div>
			<span class="text-[10px] text-zinc-500">
				{cols}x{rows} = {frameCount} frames
			</span>
			<button
				class="rounded bg-emerald-600 px-4 py-1.5 text-xs font-medium text-white hover:bg-emerald-500 disabled:opacity-40"
				disabled={frameCount === 0}
				onclick={sliceFrames}
			>
				Slice
			</button>
		{/if}
	</div>

	<div class="flex min-h-0 flex-1 overflow-auto">
		{#if imgLoaded}
			<div class="flex flex-1 flex-col gap-4 overflow-auto p-4">
				<!-- Grid preview -->
				<div class="rounded border border-zinc-800 bg-zinc-900 p-3">
					<h3 class="mb-2 text-xs font-medium text-zinc-400">
						Source ({srcWidth}x{srcHeight})
					</h3>
					<div class="overflow-auto">
						<canvas bind:this={gridCanvas} class="block"></canvas>
					</div>
				</div>

				<!-- Hidden image for loading -->
				{#if imageUrl}
					<img
						bind:this={imgEl}
						src={imageUrl}
						alt=""
						class="hidden"
						onload={handleImageLoad}
					/>
				{/if}

				<!-- Sliced frames -->
				{#if frames.length > 0}
					<div class="rounded border border-zinc-800 bg-zinc-900 p-3">
						<div class="mb-2 flex items-center justify-between">
							<h3 class="text-xs font-medium text-zinc-400">
								Frames ({frames.length})
							</h3>
							<div class="flex items-center gap-2">
								<label class="text-[10px] text-zinc-500 uppercase">Name</label>
								<input
									type="text"
									class="w-28 rounded border border-zinc-700 bg-zinc-800 px-2 py-1 text-xs text-zinc-200 outline-none focus:border-emerald-500"
									bind:value={spriteName}
								/>
							</div>
						</div>
						<div class="flex flex-wrap gap-2" style="image-rendering: pixelated">
							{#each frames as frame, i}
								<div class="flex flex-col items-center rounded border border-zinc-800 bg-zinc-950 p-1">
									<canvas class="frame-preview block"></canvas>
									<span class="mt-0.5 text-[8px] text-zinc-500">#{i}</span>
								</div>
							{/each}
						</div>
					</div>

					<!-- GPC code -->
					<div class="rounded border border-zinc-800 bg-zinc-900 p-3">
						<div class="mb-2 flex items-center justify-between">
							<h3 class="text-xs font-medium text-zinc-400">Generated GPC Code</h3>
							<button
								class="rounded bg-zinc-700 px-3 py-1 text-[10px] text-zinc-300 hover:bg-zinc-600"
								onclick={copyCode}
							>
								Copy
							</button>
						</div>
						<pre class="max-h-96 overflow-auto rounded bg-zinc-950 p-2 font-mono text-[10px] text-zinc-300">{gpcCode}</pre>
					</div>
				{/if}
			</div>
		{:else}
			<div class="flex h-full flex-1 flex-col items-center justify-center gap-3 text-zinc-600">
				<svg class="h-16 w-16 opacity-30" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
				</svg>
				<p class="text-sm">Load a sprite sheet image to begin</p>
				<p class="text-xs text-zinc-700">
					Supports PNG, JPG, BMP. Set cell size to define the frame grid.
				</p>
			</div>
		{/if}
	</div>
</div>
