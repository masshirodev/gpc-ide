/**
 * BDF (Bitmap Distribution Format) font parser.
 * Parses .bdf font files and extracts glyph bitmaps.
 */

export interface BdfGlyph {
	charCode: number;
	name: string;
	width: number;
	height: number;
	xOffset: number;
	yOffset: number;
	bitmap: number[]; // row bitmaps, MSB = leftmost pixel
}

export interface BdfFont {
	name: string;
	pointSize: number;
	xRes: number;
	yRes: number;
	boundingBox: { width: number; height: number; xOff: number; yOff: number };
	glyphs: Map<number, BdfGlyph>;
}

export function parseBdf(content: string): BdfFont {
	const lines = content.split('\n');
	const font: BdfFont = {
		name: 'Unknown',
		pointSize: 0,
		xRes: 72,
		yRes: 72,
		boundingBox: { width: 0, height: 0, xOff: 0, yOff: 0 },
		glyphs: new Map()
	};

	let i = 0;

	// Parse header
	while (i < lines.length) {
		const line = lines[i].trim();
		if (line.startsWith('FONT ')) {
			font.name = line.substring(5).trim();
		} else if (line.startsWith('SIZE ')) {
			const parts = line.split(/\s+/);
			font.pointSize = parseInt(parts[1]) || 0;
			font.xRes = parseInt(parts[2]) || 72;
			font.yRes = parseInt(parts[3]) || 72;
		} else if (line.startsWith('FONTBOUNDINGBOX ')) {
			const parts = line.split(/\s+/);
			font.boundingBox = {
				width: parseInt(parts[1]) || 0,
				height: parseInt(parts[2]) || 0,
				xOff: parseInt(parts[3]) || 0,
				yOff: parseInt(parts[4]) || 0
			};
		} else if (line === 'STARTCHAR' || line.startsWith('STARTCHAR ')) {
			// Start parsing glyphs
			break;
		}
		i++;
	}

	// Parse glyphs
	while (i < lines.length) {
		const line = lines[i].trim();
		if (line.startsWith('STARTCHAR ')) {
			const glyph = parseGlyph(lines, i);
			if (glyph) {
				font.glyphs.set(glyph.glyph.charCode, glyph.glyph);
				i = glyph.nextIndex;
			} else {
				i++;
			}
		} else {
			i++;
		}
	}

	return font;
}

function parseGlyph(
	lines: string[],
	startIndex: number
): { glyph: BdfGlyph; nextIndex: number } | null {
	const glyph: BdfGlyph = {
		charCode: -1,
		name: '',
		width: 0,
		height: 0,
		xOffset: 0,
		yOffset: 0,
		bitmap: []
	};

	let i = startIndex;
	const nameLine = lines[i].trim();
	glyph.name = nameLine.substring('STARTCHAR '.length).trim();
	i++;

	let bbWidth = 0,
		bbHeight = 0;
	let inBitmap = false;

	while (i < lines.length) {
		const line = lines[i].trim();

		if (line.startsWith('ENCODING ')) {
			glyph.charCode = parseInt(line.split(/\s+/)[1]) || -1;
		} else if (line.startsWith('BBX ')) {
			const parts = line.split(/\s+/);
			bbWidth = parseInt(parts[1]) || 0;
			bbHeight = parseInt(parts[2]) || 0;
			glyph.xOffset = parseInt(parts[3]) || 0;
			glyph.yOffset = parseInt(parts[4]) || 0;
			glyph.width = bbWidth;
			glyph.height = bbHeight;
		} else if (line === 'BITMAP') {
			inBitmap = true;
		} else if (line === 'ENDCHAR') {
			return { glyph, nextIndex: i + 1 };
		} else if (inBitmap) {
			// Parse hex row data
			const val = parseInt(line, 16);
			if (!isNaN(val)) {
				// Shift to align MSB with the glyph width
				const hexBits = line.length * 4;
				const shift = hexBits - bbWidth;
				glyph.bitmap.push(shift > 0 ? val >> shift : val);
			}
		}

		i++;
	}

	return glyph.charCode >= 0 ? { glyph, nextIndex: i } : null;
}

/**
 * Convert a BDF font to the internal BitmapFont format used by the OLED system.
 * Returns data compatible with the fonts.ts BitmapFont interface.
 */
export function bdfToBitmapFont(bdf: BdfFont): {
	width: number;
	height: number;
	spacing: number;
	data: Map<number, number[]>;
} {
	const width = bdf.boundingBox.width;
	const height = bdf.boundingBox.height;

	const data = new Map<number, number[]>();

	for (const [charCode, glyph] of bdf.glyphs) {
		// Only include printable ASCII range
		if (charCode < 32 || charCode > 126) continue;

		// Normalize glyph bitmap to font bounding box height
		const rows: number[] = new Array(height).fill(0);
		const topOffset = height - glyph.height - (glyph.yOffset - bdf.boundingBox.yOff);

		for (let r = 0; r < glyph.height; r++) {
			const destRow = topOffset + r;
			if (destRow >= 0 && destRow < height && r < glyph.bitmap.length) {
				rows[destRow] = glyph.bitmap[r];
			}
		}

		data.set(charCode, rows);
	}

	return { width, height, spacing: 1, data };
}

/**
 * Generate GPC code for a BDF font.
 */
export function generateGpcFontCode(
	fontName: string,
	bitmapFont: { width: number; height: number; spacing: number; data: Map<number, number[]> }
): string {
	const safeName = fontName.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^[0-9]/, '_$&');
	const lines: string[] = [];

	lines.push(`// Font: ${fontName} (${bitmapFont.width}x${bitmapFont.height})`);
	lines.push(`// Generated by GPC IDE - OLED Font Import`);
	lines.push(``);
	lines.push(`define FONT_${safeName.toUpperCase()}_WIDTH  = ${bitmapFont.width};`);
	lines.push(`define FONT_${safeName.toUpperCase()}_HEIGHT = ${bitmapFont.height};`);
	lines.push(``);

	// Generate a lookup array: for each char in ASCII 32..126, store row data
	const charStart = 32;
	const charEnd = 126;
	const rowsPerChar = bitmapFont.height;

	lines.push(
		`// Font data: ${charEnd - charStart + 1} chars x ${rowsPerChar} rows = ${(charEnd - charStart + 1) * rowsPerChar} entries`
	);
	lines.push(`const int8 font_${safeName}_data[] = {`);

	for (let ch = charStart; ch <= charEnd; ch++) {
		const rows = bitmapFont.data.get(ch) ?? new Array(rowsPerChar).fill(0);
		const char = String.fromCharCode(ch);
		const displayChar = ch === 92 ? '\\\\' : ch === 39 ? "\\'" : char;
		const hex = rows.map((r) => '0x' + (r & 0xff).toString(16).toUpperCase().padStart(2, '0'));
		const comma = ch < charEnd ? ',' : '';
		lines.push(`    ${hex.join(', ')}${comma} // '${displayChar}' (${ch})`);
	}

	lines.push(`};`);
	lines.push(``);

	// Generate draw function
	lines.push(`int _f_i, _f_r, _f_b, _f_px, _f_py, _f_bv;`);
	lines.push(``);
	lines.push(`function DrawText_${safeName}(int x, int y, int str[], int len) {`);
	lines.push(`    _f_px = x;`);
	lines.push(`    for(_f_i = 0; _f_i < len; _f_i++) {`);
	lines.push(`        if(str[_f_i] < ${charStart} || str[_f_i] > ${charEnd}) {`);
	lines.push(`            _f_px = _f_px + FONT_${safeName.toUpperCase()}_WIDTH + ${bitmapFont.spacing};`);
	lines.push(`            continue;`);
	lines.push(`        }`);
	lines.push(`        for(_f_r = 0; _f_r < ${rowsPerChar}; _f_r++) {`);
	lines.push(
		`            _f_bv = font_${safeName}_data[(str[_f_i] - ${charStart}) * ${rowsPerChar} + _f_r];`
	);
	lines.push(`            if(_f_bv == 0) continue;`);
	lines.push(`            for(_f_b = ${bitmapFont.width - 1}; _f_b >= 0; _f_b--) {`);
	lines.push(`                if(_f_bv & (1 << _f_b)) {`);
	lines.push(
		`                    pixel_oled(_f_px + (${bitmapFont.width - 1} - _f_b), y + _f_r, 1);`
	);
	lines.push(`                }`);
	lines.push(`            }`);
	lines.push(`        }`);
	lines.push(`        _f_px = _f_px + FONT_${safeName.toUpperCase()}_WIDTH + ${bitmapFont.spacing};`);
	lines.push(`    }`);
	lines.push(`}`);

	return lines.join('\n');
}
