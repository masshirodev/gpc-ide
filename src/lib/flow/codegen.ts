import type { FlowGraph, FlowNode, FlowEdge, FlowVariable } from '$lib/types/flow';

/**
 * Generate a complete GPC script from a FlowGraph.
 * Produces a self-contained state machine with OLED rendering.
 */
export function generateFlowGpc(graph: FlowGraph): string {
	const lines: string[] = [];
	const nodes = graph.nodes;
	const edges = graph.edges;

	if (nodes.length === 0) {
		return '// Empty flow graph — add nodes to generate code\n';
	}

	// Sort: initial state first, then by position
	const sorted = [...nodes].sort((a, b) => {
		if (a.isInitialState) return -1;
		if (b.isInitialState) return 1;
		return a.position.y - b.position.y || a.position.x - b.position.x;
	});

	const stateIds = new Map<string, number>();
	sorted.forEach((node, i) => stateIds.set(node.id, i));

	// Header
	lines.push(`// ====================================================`);
	lines.push(`// Flow: ${graph.name}`);
	lines.push(`// Generated by GPC IDE Flow Editor`);
	lines.push(`// States: ${nodes.length} | Transitions: ${edges.length}`);
	lines.push(`// ====================================================`);
	lines.push(``);

	// State defines
	lines.push(`// ===== STATE DEFINITIONS =====`);
	for (const node of sorted) {
		const id = stateIds.get(node.id)!;
		const safeName = sanitizeName(node.label);
		lines.push(`define FLOW_STATE_${safeName} = ${id};`);
	}
	lines.push(``);

	// Variables
	lines.push(`// ===== VARIABLES =====`);
	lines.push(`int FlowCurrentState;`);
	lines.push(`int FlowPrevState = -1;`);
	lines.push(`int FlowStateTimer;`);
	lines.push(``);

	// Global variables
	if (graph.globalVariables.length > 0) {
		lines.push(`// Global flow variables`);
		for (const v of graph.globalVariables) {
			lines.push(`${v.type} ${v.name} = ${v.defaultValue};`);
		}
		lines.push(``);
	}

	// Per-node variables
	const declaredVars = new Set<string>(['FlowCurrentState', 'FlowPrevState', 'FlowStateTimer']);
	for (const node of sorted) {
		if (node.variables.length > 0) {
			lines.push(`// Variables for ${node.label}`);
			for (const v of node.variables) {
				if (!declaredVars.has(v.name)) {
					lines.push(`${v.type} ${v.name} = ${v.defaultValue};`);
					declaredVars.add(v.name);
				}
			}
			lines.push(``);
		}
	}

	// Global code
	if (graph.globalCode.trim()) {
		lines.push(`// ===== GLOBAL CODE =====`);
		lines.push(graph.globalCode.trim());
		lines.push(``);
	}

	// OLED draw functions (one per node with an OLED scene)
	for (const node of sorted) {
		if (node.oledScene) {
			lines.push(`// ===== DRAW: ${node.label} =====`);
			lines.push(generateOledDrawFunction(node));
			lines.push(``);
		}
	}

	// State logic functions
	for (const node of sorted) {
		const safeName = sanitizeName(node.label);
		const outEdges = edges.filter((e) => e.sourceNodeId === node.id);

		lines.push(`// ===== STATE: ${node.label} =====`);
		lines.push(`function FlowState_${safeName}() {`);

		// onEnter logic (runs once when entering state)
		if (node.onEnter.trim()) {
			lines.push(`    // On enter`);
			lines.push(`    if(FlowPrevState != FLOW_STATE_${safeName}) {`);
			for (const line of node.onEnter.trim().split('\n')) {
				lines.push(`        ${line.trim()}`);
			}
			lines.push(`    }`);
		}

		// Draw OLED
		if (node.oledScene) {
			lines.push(`    Draw_Flow_${safeName}();`);
		}

		// Main logic
		if (node.gpcCode.trim()) {
			lines.push(`    // Logic`);
			for (const line of node.gpcCode.trim().split('\n')) {
				lines.push(`    ${line}`);
			}
		}

		// Transitions
		if (outEdges.length > 0) {
			lines.push(`    // Transitions`);
			for (const edge of outEdges) {
				const targetNode = nodes.find((n) => n.id === edge.targetNodeId);
				if (!targetNode) continue;
				const targetName = sanitizeName(targetNode.label);
				const condition = generateConditionCode(edge);

				if (condition) {
					lines.push(`    if(${condition}) {`);
					// onExit
					if (node.onExit.trim()) {
						for (const line of node.onExit.trim().split('\n')) {
							lines.push(`        ${line.trim()}`);
						}
					}
					lines.push(`        FlowCurrentState = FLOW_STATE_${targetName};`);
					lines.push(`    }`);
				}
			}
		}

		lines.push(`}`);
		lines.push(``);
	}

	// Combo code (collected from all nodes)
	const allCombos = sorted.filter((n) => n.comboCode.trim()).map((n) => n.comboCode.trim());
	if (allCombos.length > 0) {
		lines.push(`// ===== COMBOS =====`);
		for (const combo of allCombos) {
			lines.push(combo);
			lines.push(``);
		}
	}

	// Persistence functions
	if (graph.settings.persistenceEnabled) {
		const persistVars = collectPersistVars(graph);
		if (persistVars.length > 0) {
			lines.push(`// ===== PERSISTENCE =====`);
			lines.push(generatePersistence(persistVars));
			lines.push(``);
		}
	}

	// Init block
	const initialState = sorted[0];
	const initialName = sanitizeName(initialState.label);
	lines.push(`// ===== INIT =====`);
	lines.push(`init {`);
	lines.push(`    FlowCurrentState = FLOW_STATE_${initialName};`);
	if (graph.settings.persistenceEnabled && collectPersistVars(graph).length > 0) {
		lines.push(`    Flow_Load();`);
	}
	lines.push(`}`);
	lines.push(``);

	// Main loop
	lines.push(`// ===== MAIN LOOP =====`);
	lines.push(`main {`);
	lines.push(`    // State dispatch`);
	for (const node of sorted) {
		const id = stateIds.get(node.id)!;
		const safeName = sanitizeName(node.label);
		const keyword = id === 0 ? 'if' : 'else if';
		lines.push(`    ${keyword}(FlowCurrentState == FLOW_STATE_${safeName}) { FlowState_${safeName}(); }`);
	}
	lines.push(``);
	lines.push(`    // State timer`);
	lines.push(`    if(FlowCurrentState != FlowPrevState) {`);
	lines.push(`        FlowStateTimer = 0;`);
	lines.push(`        FlowPrevState = FlowCurrentState;`);
	lines.push(`    }`);
	lines.push(`    FlowStateTimer = FlowStateTimer + get_rtime();`);
	lines.push(`}`);

	return lines.join('\n');
}

function sanitizeName(name: string): string {
	return name
		.replace(/[^a-zA-Z0-9_]/g, '_')
		.replace(/^[0-9]/, '_$&')
		.replace(/_+/g, '_');
}

function generateConditionCode(edge: FlowEdge): string | null {
	const c = edge.condition;
	switch (c.type) {
		case 'button_press':
			return c.button ? `event_press(${c.button})` : null;
		case 'button_hold':
			return c.button && c.timeoutMs
				? `get_val(${c.button}) && FlowStateTimer > ${c.timeoutMs}`
				: c.button
					? `get_val(${c.button})`
					: null;
		case 'timeout':
			return c.timeoutMs ? `FlowStateTimer > ${c.timeoutMs}` : null;
		case 'variable':
			return c.variable && c.comparison
				? `${c.variable} ${c.comparison} ${c.value ?? 0}`
				: null;
		case 'custom':
			return c.customCode?.trim() || null;
		default:
			return null;
	}
}

function generateOledDrawFunction(node: FlowNode): string {
	const safeName = sanitizeName(node.label);
	const lines: string[] = [];

	lines.push(`function Draw_Flow_${safeName}() {`);
	lines.push(`    cls_oled(OLED_BLACK);`);

	if (node.oledScene) {
		// Decode base64 pixels and generate pixel_oled calls
		try {
			const binaryStr = atob(node.oledScene.pixels);
			const bytes = new Uint8Array(binaryStr.length);
			for (let i = 0; i < binaryStr.length; i++) {
				bytes[i] = binaryStr.charCodeAt(i);
			}

			for (let y = 0; y < 64; y++) {
				for (let x = 0; x < 128; x++) {
					const byteIdx = y * 16 + Math.floor(x / 8);
					const bitIdx = 7 - (x % 8);
					if (byteIdx < bytes.length && (bytes[byteIdx] & (1 << bitIdx)) !== 0) {
						lines.push(`    pixel_oled(${x}, ${y}, 1);`);
					}
				}
			}
		} catch {
			lines.push(`    // Error decoding OLED scene data`);
		}
	}

	lines.push(`}`);
	return lines.join('\n');
}

function collectPersistVars(graph: FlowGraph): FlowVariable[] {
	const vars: FlowVariable[] = [];
	const seen = new Set<string>();

	for (const v of graph.globalVariables) {
		if (v.persist && !seen.has(v.name)) {
			vars.push(v);
			seen.add(v.name);
		}
	}
	for (const node of graph.nodes) {
		for (const v of node.variables) {
			if (v.persist && !seen.has(v.name)) {
				vars.push(v);
				seen.add(v.name);
			}
		}
	}

	return vars;
}

function generatePersistence(vars: FlowVariable[]): string {
	const lines: string[] = [];

	// Simple SPVAR persistence — each variable gets its own slot
	lines.push(`function Flow_Save() {`);
	vars.forEach((v, i) => {
		lines.push(`    set_pvar(SPVAR_${i + 1}, ${v.name});`);
	});
	lines.push(`    set_pvar(SPVAR_0, 1); // Data exists marker`);
	lines.push(`}`);
	lines.push(``);
	lines.push(`function Flow_Load() {`);
	lines.push(`    if(get_pvar(SPVAR_0) == 0) return;`);
	vars.forEach((v, i) => {
		lines.push(`    ${v.name} = get_pvar(SPVAR_${i + 1});`);
	});
	lines.push(`}`);

	return lines.join('\n');
}
