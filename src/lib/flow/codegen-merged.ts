import type { FlowProject, FlowVariable, FlowProfile, ProfileSwitchConfig } from '$lib/types/flow';
import { generateFlowGpc } from './codegen';
import { generateGameplayGpc, generateGameplayGpcStandalone } from './codegen-gameplay';

/**
 * Generate a single merged GPC script from an entire FlowProject.
 *
 * Combines the menu flow (state machine) and gameplay flow (parallel modules)
 * into one cohesive script. Shared variables are declared once and used by both.
 */
export function generateMergedFlowGpc(project: FlowProject): string {
	const menuFlow = project.flows.find((f) => f.flowType === 'menu');
	const gameplayFlow = project.flows.find((f) => f.flowType === 'gameplay');

	const hasMenu = menuFlow && menuFlow.nodes.length > 0;
	const hasGameplay = gameplayFlow && gameplayFlow.nodes.some((n) => n.type === 'module' || n.type === 'custom');

	const profiles = project.profiles ?? [];
	const profileCount = profiles.length;

	// If only one flow has content, just generate that one
	if (hasMenu && !hasGameplay) {
		return generateFlowGpc(menuFlow, profileCount);
	}
	if (!hasMenu && hasGameplay) {
		return generateGameplayGpcStandalone(gameplayFlow!);
	}
	if (!hasMenu && !hasGameplay) {
		return '// Empty flow project — add nodes to generate code\n';
	}

	// Both flows have content — merge them
	const gameplayResult = generateGameplayGpc(gameplayFlow!);
	const menuCode = generateFlowGpc(menuFlow!, profileCount);

	const lines: string[] = [];

	lines.push(`// ====================================================`);
	lines.push(`// Merged Flow Project`);
	lines.push(`// Menu Flow + Gameplay Flow`);
	if (profileCount > 1) {
		lines.push(`// Profiles: ${profiles.map((p) => p.name).join(', ')}`);
	}
	lines.push(`// Generated by GPC IDE Flow Editor`);
	lines.push(`// ====================================================`);
	lines.push('');

	// Profile variables (when multiple profiles are configured)
	if (profileCount > 1) {
		lines.push(`// ===== PROFILE SYSTEM =====`);
		lines.push(`define FLOW_PROFILE_COUNT = ${profileCount};`);
		lines.push(`int Flow_CurrentProfile = 0;`);
		lines.push('');
	}

	// Shared variables
	if (project.sharedVariables.length > 0) {
		lines.push(`// ===== SHARED VARIABLES =====`);
		for (const v of project.sharedVariables) {
			lines.push(generateVarDecl(v, profileCount));
		}
		lines.push('');
	}

	// Shared code
	if (project.sharedCode.trim()) {
		lines.push(`// ===== SHARED CODE =====`);
		lines.push(project.sharedCode.trim());
		lines.push('');
	}

	// Gameplay variables (exclude any already declared as shared)
	const sharedVarNames = new Set(project.sharedVariables.map((v) => v.name));
	const gameplayVars = gameplayResult.variables.filter((decl) => {
		const match = decl.match(/(?:int|int8|int16|int32)\s+(\w+)/);
		return match ? !sharedVarNames.has(match[1]) : true;
	});

	if (gameplayVars.length > 0) {
		lines.push(`// ===== GAMEPLAY VARIABLES =====`);
		lines.push(...gameplayVars);
		lines.push('');
	}

	// Insert the full menu code but strip its main {} block — we'll merge mains
	const menuLines = menuCode.split('\n');
	const mainStartIdx = menuLines.findIndex((l) => l.trim().startsWith('main {'));
	const initStartIdx = menuLines.findIndex((l) => l.trim().startsWith('init {'));

	// Everything before init is declarations/functions
	const preInit = menuLines.slice(0, initStartIdx >= 0 ? initStartIdx : mainStartIdx >= 0 ? mainStartIdx : menuLines.length);
	lines.push(`// ===== MENU FLOW =====`);
	lines.push(...preInit);

	// Gameplay combos
	if (gameplayResult.combos.length > 0) {
		lines.push(`// ===== GAMEPLAY COMBOS =====`);
		lines.push(...gameplayResult.combos);
	}

	// Gameplay functions
	if (gameplayResult.functions.length > 0) {
		lines.push(`// ===== GAMEPLAY FUNCTIONS =====`);
		lines.push(...gameplayResult.functions);
		lines.push('');
	}

	// Merged init block
	const hasGameplayInit = gameplayResult.initCode.length > 0;
	if (initStartIdx >= 0) {
		const initEndIdx = findBlockEnd(menuLines, initStartIdx);
		lines.push(`// ===== INIT =====`);
		if (hasGameplayInit) {
			// Merge: menu init body + gameplay init code
			lines.push(`init {`);
			const menuInitBody = menuLines.slice(initStartIdx + 1, initEndIdx);
			lines.push(`    // --- Menu Init ---`);
			lines.push(...menuInitBody);
			lines.push('');
			lines.push(`    // --- Gameplay Init ---`);
			lines.push(...gameplayResult.initCode);
			lines.push(`}`);
		} else {
			lines.push(...menuLines.slice(initStartIdx, initEndIdx + 1));
		}
		lines.push('');
	} else if (hasGameplayInit) {
		// No menu init, but gameplay has init code
		lines.push(`// ===== INIT =====`);
		lines.push(`init {`);
		lines.push(...gameplayResult.initCode);
		lines.push(`}`);
		lines.push('');
	}

	// Merged main block
	lines.push(`// ===== MAIN LOOP =====`);
	lines.push(`main {`);

	// Profile switching (before menu/gameplay code)
	if (profileCount > 1 && project.profileSwitch) {
		lines.push('');
		lines.push(`    // --- Profile Switching ---`);
		lines.push(...generateProfileSwitchCode(project.profileSwitch, profileCount));
	}

	// Menu state dispatch (extract main body)
	if (mainStartIdx >= 0) {
		const mainEndIdx = findBlockEnd(menuLines, mainStartIdx);
		const menuMainBody = menuLines.slice(mainStartIdx + 1, mainEndIdx);
		lines.push(`    // --- Menu Flow ---`);
		lines.push(...menuMainBody);
	}

	// Gameplay triggers
	if (gameplayResult.mainLoopCode.length > 0) {
		lines.push('');
		lines.push(`    // --- Gameplay Flow ---`);
		lines.push(...gameplayResult.mainLoopCode);
	}

	lines.push(`}`);

	return lines.join('\n');
}

// ==================== Helpers ====================

function generateVarDecl(v: FlowVariable, profileCount: number = 0): string {
	if (v.perProfile && profileCount > 1 && v.type !== 'string') {
		const defaults = Array(profileCount).fill(v.defaultValue).join(', ');
		return `${v.type} ${v.name}[${profileCount}] = { ${defaults} };`;
	}
	if (v.type === 'string') {
		const size = v.arraySize ?? 32;
		return `int8 ${v.name}[${size}];`;
	}
	return `${v.type} ${v.name} = ${v.defaultValue};`;
}

/**
 * Generate profile switch code for the main loop.
 */
function generateProfileSwitchCode(config: ProfileSwitchConfig, profileCount: number): string[] {
	const lines: string[] = [];
	const mod = config.modifier ? `get_val(${config.modifier}) && ` : '';

	lines.push(`    if(${mod}event_press(${config.next})) {`);
	lines.push(`        Flow_CurrentProfile = Flow_CurrentProfile + 1;`);
	lines.push(`        if(Flow_CurrentProfile >= ${profileCount}) Flow_CurrentProfile = 0;`);
	lines.push(`    }`);

	if (config.prev) {
		lines.push(`    if(${mod}event_press(${config.prev})) {`);
		lines.push(`        if(Flow_CurrentProfile > 0) Flow_CurrentProfile = Flow_CurrentProfile - 1;`);
		lines.push(`        else Flow_CurrentProfile = ${profileCount - 1};`);
		lines.push(`    }`);
	}

	return lines;
}

/**
 * Find the closing brace index for a block starting at `startIdx`.
 */
function findBlockEnd(lines: string[], startIdx: number): number {
	let depth = 0;
	for (let i = startIdx; i < lines.length; i++) {
		for (const ch of lines[i]) {
			if (ch === '{') depth++;
			if (ch === '}') depth--;
			if (depth === 0 && i > startIdx) return i;
		}
	}
	return lines.length - 1;
}
